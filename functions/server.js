const { onRequest, onCall, HttpsError } = require('firebase-functions/v2/https');
const admin = require('firebase-admin');
const { getFirestore } = require('firebase-admin/firestore');

// Initialize Firebase Admin (only once)
if (!admin.apps.length) {
  admin.initializeApp();
}

// =============================================================================
// SSR Handler for Next.js (auto-generated by Firebase)
// =============================================================================
const server = import('firebase-frameworks');
// Admin SDK secrets required for session cookies, campaign creation, portraits, etc.
// Must match firebase.json hosting.frameworksBackend.secrets and Secret Manager.
const ADMIN_SDK_SECRETS = ['SERVICE_ACCOUNT_EMAIL', 'SERVICE_ACCOUNT_PRIVATE_KEY'];

exports.ssrrealmsrpgtest = onRequest(
  { region: 'us-central1', secrets: ADMIN_SDK_SECRETS },
  (req, res) => server.then((it) => it.handle(req, res))
);

// =============================================================================
// Cloud Functions for Library Save/Load Operations
// =============================================================================

/**
 * Save Power to Library
 */
exports.savePowerToLibrary = onCall(async (request) => {
  const { powerName, powerDescription, parts, damage } = request.data;
  const uid = request.auth?.uid;

  if (!uid) {
    throw new HttpsError('unauthenticated', 'You must be authenticated to save a power.');
  }

  if (!(typeof powerName === "string") || powerName.trim().length === 0) {
    throw new HttpsError("invalid-argument", "Power name is required.");
  }
  if (!Array.isArray(parts)) {
    throw new HttpsError("invalid-argument", "Missing or invalid 'parts' array.");
  }
  if (!Array.isArray(damage)) {
    throw new HttpsError("invalid-argument", "Missing or invalid 'damage' array.");
  }

  try {
    const db = getFirestore();
    const powersRef = db.collection('users').doc(uid).collection('library');
    const querySnap = await powersRef.where('name', '==', powerName).get();
    
    let docRef;
    if (!querySnap.empty) {
      docRef = powersRef.doc(querySnap.docs[0].id);
    } else {
      docRef = powersRef.doc();
    }
    
    await docRef.set({
      name: powerName,
      description: powerDescription || "",
      parts,
      damage,
      timestamp: new Date()
    });
    
    console.log('Power saved with ID:', docRef.id);
    return { message: 'Power saved to library', docId: docRef.id };
  } catch (error) {
    console.error('Error saving power:', error);
    throw new HttpsError('internal', 'Error saving power to library');
  }
});

/**
 * Delete Power from Library
 */
exports.deletePowerFromLibrary = onCall(async (request) => {
  const { powerId } = request.data;
  const uid = request.auth?.uid;

  if (!uid) {
    throw new HttpsError('unauthenticated', 'You must be authenticated.');
  }

  try {
    const db = getFirestore();
    await db.collection('users').doc(uid).collection('library').doc(powerId).delete();
    return { message: 'Power deleted successfully' };
  } catch (error) {
    console.error('Error deleting power:', error);
    throw new HttpsError('internal', 'Error deleting power');
  }
});

/**
 * Save Item to Library
 */
exports.saveItemToLibrary = onCall(async (request) => {
  const { itemName, itemDescription, armamentType, properties, damage } = request.data;
  const uid = request.auth?.uid;

  if (!uid) {
    throw new HttpsError('unauthenticated', 'You must be authenticated to save an item.');
  }

  if (!(typeof itemName === "string") || itemName.length === 0) {
    throw new HttpsError("invalid-argument", "Item name is required.");
  }

  if (!armamentType || !['Weapon', 'Armor', 'Shield'].includes(armamentType)) {
    throw new HttpsError("invalid-argument", "Invalid armament type.");
  }

  if (!Array.isArray(properties)) {
    throw new HttpsError("invalid-argument", "Properties must be an array.");
  }

  try {
    const db = getFirestore();
    const docRef = await db.collection('users').doc(uid).collection('itemLibrary').add({
      name: itemName,
      description: itemDescription || "",
      armamentType,
      properties,
      damage: damage || [],
      timestamp: new Date()
    });
    
    console.log('Item saved with ID:', docRef.id);
    return { message: 'Item saved to library', docId: docRef.id };
  } catch (error) {
    console.error('Error saving item:', error);
    throw new HttpsError('internal', 'Error saving item to library: ' + error.message);
  }
});

/**
 * Save Technique to Library
 */
exports.saveTechniqueToLibrary = onCall(async (request) => {
  const { techniqueName, techniqueDescription, parts, weapon, damage } = request.data;
  const uid = request.auth?.uid;

  if (!uid) {
    throw new HttpsError('unauthenticated', 'You must be authenticated to save a technique.');
  }

  if (!(typeof techniqueName === "string") || techniqueName.trim().length === 0) {
    throw new HttpsError("invalid-argument", "Technique name is required.");
  }
  if (!Array.isArray(parts)) {
    throw new HttpsError("invalid-argument", "Missing or invalid 'parts' array.");
  }
  if (!damage || typeof damage !== "object" || !("amount" in damage) || !("size" in damage)) {
    throw new HttpsError("invalid-argument", "Missing or invalid 'damage' object.");
  }
  if (!weapon || typeof weapon !== "object" || !("name" in weapon)) {
    throw new HttpsError("invalid-argument", "Missing or invalid 'weapon' object.");
  }

  try {
    const db = getFirestore();
    const techniquesRef = db.collection('users').doc(uid).collection('techniqueLibrary');
    const querySnap = await techniquesRef.where('name', '==', techniqueName).get();
    
    let docRef;
    if (!querySnap.empty) {
      docRef = techniquesRef.doc(querySnap.docs[0].id);
    } else {
      docRef = techniquesRef.doc();
    }
    
    await docRef.set({
      name: techniqueName,
      description: techniqueDescription || "",
      parts,
      weapon,
      damage,
      timestamp: new Date()
    });
    
    console.log('Technique saved with ID:', docRef.id);
    return { message: 'Technique saved to library', docId: docRef.id };
  } catch (error) {
    console.error('Error saving technique:', error);
    throw new HttpsError('internal', 'Error saving technique to library');
  }
});

/**
 * Delete Technique from Library
 */
exports.deleteTechniqueFromLibrary = onCall(async (request) => {
  const { techniqueId } = request.data;
  const uid = request.auth?.uid;

  if (!uid) {
    throw new HttpsError('unauthenticated', 'You must be authenticated.');
  }

  try {
    const db = getFirestore();
    await db.collection('users').doc(uid).collection('techniqueLibrary').doc(techniqueId).delete();
    return { message: 'Technique deleted successfully' };
  } catch (error) {
    console.error('Error deleting technique:', error);
    throw new HttpsError('internal', 'Error deleting technique');
  }
});

/**
 * Save Creature to Library
 */
exports.saveCreatureToLibrary = onCall(async (request) => {
  const { creatureName, creatureData } = request.data;
  const uid = request.auth?.uid;

  if (!uid) {
    throw new HttpsError('unauthenticated', 'You must be authenticated to save a creature.');
  }
  if (!(typeof creatureName === "string") || creatureName.length === 0) {
    throw new HttpsError("invalid-argument", "Creature name is required.");
  }
  if (!creatureData || typeof creatureData !== "object") {
    throw new HttpsError("invalid-argument", "Missing or invalid creature data.");
  }

  try {
    const db = getFirestore();
    const docRef = await db.collection('users').doc(uid).collection('creatureLibrary').add({
      name: creatureName,
      ...creatureData,
      timestamp: new Date()
    });
    
    console.log('Creature saved with ID:', docRef.id);
    return { message: 'Creature saved to library', docId: docRef.id };
  } catch (error) {
    console.error('Error saving creature:', error);
    throw new HttpsError('internal', 'Error saving creature to library');
  }
});

/**
 * Save Character
 */
exports.saveCharacter = onCall(async (request) => {
  const characterData = request.data;
  const uid = request.auth?.uid;

  if (!uid) {
    throw new HttpsError('unauthenticated', 'You must be authenticated to save a character.');
  }

  const { name, species } = characterData;

  if (!(typeof name === "string") || name.trim().length === 0) {
    throw new HttpsError("invalid-argument", "Character name is required.");
  }
  if (!(typeof species === "string") || species.trim().length === 0) {
    throw new HttpsError("invalid-argument", "Species is required.");
  }

  try {
    const db = getFirestore();
    const charDocId = name.trim();
    
    await db.collection('users').doc(uid).collection('character').doc(charDocId).set({
      ...characterData,
      timestamp: new Date()
    });
    
    console.log('Character saved:', charDocId);
    return { message: 'Character saved successfully', docId: charDocId };
  } catch (error) {
    console.error('Error saving character:', error);
    throw new HttpsError('internal', 'Error saving character: ' + error.message);
  }
});
